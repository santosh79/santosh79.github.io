<!doctype html>
<html>
  <head>
    <link rel="stylesheet" type="text/css" href="/css/main.css">
    <link rel="alternate" type="application/atom+xml" title="Erlang vs. NodeJS - A tale of two concurrency models - feed" href="/index.xml" />

    <script type="text/javascript">
      if((navigator.userAgent.match(/iPad/i))) {
        document.write("<meta name=\"viewport\" content=\"width=device-width; initial-scale=1.0; maximum-scale=1.0; user-scalable=0;\" />");
      } else if((navigator.userAgent.match(/iPhone/i))) {
        document.write("<meta name=\"viewport\" content=\"width=device-width; initial-scale=0.5; maximum-scale=1.0; user-scalable=1;\" />");
      }
    </script>

    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/> 
    <title>Erlang vs. NodeJS - A tale of two concurrency models</title>
  </head>
  <body>
    <header id="main_header">
      <span>
        <a href="/">blog</a>
      </span>
      <span>
        <a href="http://santosh79.tumblr.com" target="_blank">tumblog</a>
      </span>
      <span>
        <a href="http://github.com/santosh79/" target="_blank">github</a>
      </span>
      <span>
        <a href="http://twitter.com/santosh79" target="_blank">@santosh79</a>
      </span>
      <span>
        <a href="/images/resume.html">resume</a>
      </span>
    </header>
    <section>
      <article class="post">
  <header>
    <div class="date_article_page">December 20th 2014</div>
    <h1>Erlang vs. NodeJS - A tale of two concurrency models</h1>
  </header>

  <section class="content">
    <p>Recently, I ran into this pretty common problem &ndash; given a bunch of URLs figure out which of those are broken. Now, this is a problem screaming for some kind of parallelism, which makes it the perfect example to compare two concurrency models &ndash; in this case Erlangs message passing model with NodeJS&rsquo;s single thread but aysnc I/O model.</p>

<p>Here are the results.</p>

<h3>NodeJS</h3>

<p>The NodeJS solution might look something like this:</p>

<pre><code>function brokenUrls(urls, cb) {
  var brokenUrls = [];
  var pending    = urls.length;
  urls.forEach(function(url) {
    urlChecker.isValidUrl(url, function(isValid) {
      if (!isValidUrl) { brokenUrls.push(url); }
      if(--pending === 0) { cb([brokenUrls]) }
    });
  });
}
</code></pre>

<h3>Erlang</h3>

<p>And here&rsquo;s what it might look like in Erlang:</p>

<pre><code>find_broken_links(Urls) -&gt;
  lists:foreach(fun(Url) -&gt; spawn(url_checker, is_working_url, [self(), Url]) end, Urls)
  get_results(length(Urls)).

get_results(N) -&gt; get_results(0, N, []).

get_results(N, N, BrokenLinks)   -&gt; {ok, BrokenLinks};
get_results(Cnt, N, BrokenLinks) -&gt;
  receive
    {_Client, Url, true}  -&gt; get_results(Cnt + 1, N, BrokenLinks);
    {_Client, Url, false} -&gt; get_results(Cnt + 1, N, [Url|BrokenLinks])
  end.
</code></pre>

<h3>Semantics</h3>

<p>Just by looking at the code, here are couple of things that stand out in my mind:</p>

<h4>Pattern Matching</h4>

<p>The pattern matching in Erlang, especially as a Guard to a function is so beautiful. It&rsquo;s almost self-documenting. Check out:</p>

<pre><code>get_results(N, N, BrokenLinks) -&gt; {ok, BrokenLinks};
</code></pre>

<p>This literally means when we have all of the results, we are done &ndash; i.e. the counter (the first argument) and the value to count to (second argument) match.</p>

<h4>Message Passing vs. State</h4>

<p>In the NodeJS solution, there was some shared memory. Well, not quite shared memory given that NodeJS is single-threaded, but some kind of global. Here what I am referring to is:</p>

<pre><code>  var brokenUrls = [];
  var pending    = urls.length;
</code></pre>

<p>In the callbacks we are manipulating these, like so:</p>

<pre><code>  if (!isValidUrl) { brokenUrls.push(url); }
  if(--pending === 0) { cb([brokenUrls]) }
</code></pre>

<p>And the reason, we are able to get away with it without having crazy race conditions and clobbering this shared memory is because NodeJS is single-threaded.</p>

<p>In Erlang though there is absolutely no shared state. The <strong>find_broken_links</strong> function spawns a bunch of light-weight processes, one for each of the URLs it needs to check and asks them to notify itself when they have finished checking that URL. This is accomplished by two steps:</p>

<p>One &ndash; it tells each of the light-weight processes who it is (so that they know who to notify when they are done with their job):</p>

<pre><code>spawn(url_checker, is_working_url, [self(), Url])
</code></pre>

<p>Here, self() is the PID of the caller so the <strong>url_checker</strong> knows who to send the result back to.</p>

<p>Two &ndash; it waits for responses from the light-weight processes:</p>

<pre><code>receive
  {_Client, Url, true}  -&gt; get_results(Cnt + 1, N, BrokenLinks);
  {_Client, Url, false} -&gt; get_results(Cnt + 1, N, [Url|BrokenLinks])
end.
</code></pre>

<h3>Thoughts</h3>

<p>I think the Erlang code is just so much nicer and easier to understand. Not to mention, the use of immutable datastructures really makes one feel confident. Finally, in terms of performance I&rsquo;ve got to feel that Erlang would just fly a lot faster when the number of URLs to scrape shoots up since the number of light-weight processes in the Erlang VM would have to be significantly higher than the number of parallel requests that can be made from a NodeJS VM. I might be wrong here, but just a hunch.</p>

  </section>

  <section class="comments">

    <div id="disqus_thread"></div>
    <script type='text/javascript' src='http://santosh-log.disqus.com/embed.js'></script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>


  </section>
</article>

 
    </section>
  
  
  
  
  
  
  </body>
</html>

