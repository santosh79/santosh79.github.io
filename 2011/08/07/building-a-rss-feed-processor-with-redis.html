<!doctype html>
<html>
  <head>
    <link rel="stylesheet" type="text/css" href="/css/main.css">
    <link rel="alternate" type="application/atom+xml" title="Building a RSS feed processor with Redis - feed" href="/index.xml" />

    <script type="text/javascript">
      if((navigator.userAgent.match(/iPad/i))) {
        document.write("<meta name=\"viewport\" content=\"width=device-width; initial-scale=1.0; maximum-scale=1.0; user-scalable=0;\" />");
      } else if((navigator.userAgent.match(/iPhone/i))) {
        document.write("<meta name=\"viewport\" content=\"width=device-width; initial-scale=0.5; maximum-scale=1.0; user-scalable=1;\" />");
      }
    </script>

    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/> 
    <title>Building a RSS feed processor with Redis</title>
  </head>
  <body>
    <header id="main_header">
      <span>
        <a href="/">blog</a>
      </span>
      <span>
        <a href="http://santosh79.tumblr.com" target="_blank">tumblog</a>
      </span>
      <span>
        <a href="http://github.com/santosh79/" target="_blank">github</a>
      </span>
      <span>
        <a href="http://twitter.com/santosh79" target="_blank">@santosh79</a>
      </span>
      <span>
        <a href="/images/resume.html">resume</a>
      </span>
    </header>
    <section>
      <article class="post">
  <header>
    <div class="date_article_page">August 7th 2011</div>
    <h1>Building a RSS feed processor with Redis</h1>
  </header>

  <section class="content">
    <p>Redis is great for a lot of things such as: acting as a cache, storing your app&rsquo;s configuration etc. In this post, I am going to use Redis' atomic and blocking facilities to build a multi-step RSS feed processor. Along the way, some of the topics I hope to touch upon are: queue priorization, synchronization between processes, using redis to gracefully shutdown processes and a few race conditions to watch out for.</p>

<h3>Step 1: Getting a basic RSS feed processor up and running</h3>

<p>This is what the RSS feed processor is going to try to do:</p>

<ul>
<li>1: It&rsquo;s going to have a list of Feed URL&rsquo;s it&rsquo;s going to have hit periodically and get new feeds from.</li>
<li>2: When it find&rsquo;s a new feed it&rsquo;s going to <strong>process</strong> it. For now, let&rsquo;s just assume processing it means, storing it in redis somewhere.</li>
</ul>


<p>Getting step 1 running is fairly simple. I&rsquo;m going to be using the ruby stdlib&rsquo;s rss library for doing the RSS feed processing. In terms of organizing my redis datastructure&rsquo;s I&rsquo;ll use a list called <strong>feeds_to_fetch</strong> which I will be using to pop URL&rsquo;s from and determine which needs to fetched next. I&rsquo;ll also use another list called <strong>entries_needing_processing</strong> into which I&rsquo;ll stick RSS entries that need to be processed. So, given that short intro here is how a first pass at building this thing looks:</p>

<pre><code>URLS = %W{http://www.npr.org/rss/rss.php?id=1001
          http://www.npr.org/rss/rss.php?id=100}

redis = Redis.new

URLS.each { |url| redis.rpush "feeds_to_fetch", url }

loop do
  queue, payload = redis.blpop "feeds_to_fetch", "entries_needing_processing", 0
  if queue == "feeds_to_fetch"
    # Fetch feeds
    feed_url = payload
    puts "fetching feed: #{feed_url}"
    content = open(feed_url) { |s| s.read }
    rss = RSS::Parser.parse content, false
    rss.items.each do |entry|
      redis.rpush "entries_needing_processing", Marshal.dump([feed_url,entry])
    end
    redis.rpush "feeds_to_fetch", feed_url
  else
    # Process entries
    entry = Marshal.load payload
    puts "processing entry: #{entry.url}"
    entry_id = redis.incr "entries_processed"
    redis.hmset "entry|#{entry_id}", "url", entry.url, "title", entry.title, 
                "published", entry.published, "description", entry.summary
    redis.sadd "entry_ids", entry_id
  end
end
</code></pre>

<p>So this code looks simple enough. There are a bunch of URL&rsquo;s that are dumped onto the feeds_to_fetch list. We then infinitely loop, doing a <a href="http://redis.io/commands/blpop">BLPOP</a> over multiple lists (feeds_to_fetch and entries_needing_processing). From the BLPOP we branch into two code paths:</p>

<ol>
<li>If we just popped something from the <em>feeds_to_fetch</em> list, we know the value we just popped is a RSS feed url and we proceed with getting it&rsquo;s feed. Once we are done fetching the feed, we push the entries onto the <em>entries_needing_processing</em> list.</li>
<li>On the other hand, if we popped something from the <em>entries_needing_processing</em> list, we know it&rsquo;s a RSS entry and we go ahead and <em>process</em> it, i.e. store it in Redis, for now.</li>
</ol>


<p>While this code looks like it should work, when we run it we see that all we are doing is fetching feed_url&rsquo;s and not processing any of our entries. Here is a sample output from my run:</p>

<pre><code>fetching feed: http://www.npr.org/rss/rss.php?id=1008
fetching feed: http://www.npr.org/rss/rss.php?id=100
fetching feed: http://www.npr.org/rss/rss.php?id=1001
fetching feed: http://www.npr.org/rss/rss.php?id=1006
</code></pre>

<p>As you can see, all we are doing is fetching feeds with no processing of entries. Welcome to the first race condition!</p>

<h3>Prioritization of Queues in BLPOP</h3>

<p>To re-iterate the behavior we are seeing is that we are constantly fetching feed&rsquo;s and not processing any entries.Why is this happening? In order to understand why, we need to pay closer attention to the following line:</p>

<pre><code>  queue, payload = redis.blpop "feeds_to_fetch", "entries_needing_processing", 0
</code></pre>

<p>What we are doing here is telling redis to pop an item off either the feeds_to_fetch or the entries_needing_processing lists <em>in that order</em> (the trailing 0 argument just means block forever). To further clarify, we are telling redis try giving me something from the feeds_to_fetch list, if you don&rsquo;t find anything there <strong>then</strong> try giving me something from the entries_needing_processing list. So, we are giving the feeds_to_fetch list a higher order of priority than the entries_needing_processing list by specifying it before. This combined with the fact that, when we pop an item off the feeds_to_fetch list we are pushing it back means that we never are going to ever get to popping an item off the entries_needing_processing list. How do we fix this?</p>

<p>One solution is to <strong>not</strong> push the feed_url back onto the feeds_to_fetch list immediately. Rather wait, till we process all it&rsquo;s entries and then stick it back on. While this would work, it makes our code a little more complicated. We now need to keep track of when all the entries of a given feed_url are processed etc. A simpler far more elegant solution is to just switch the priorities of list in the BLPOP to:</p>

<pre><code>  queue, payload = redis.blpop "entries_needing_processing", "feeds_to_fetch",  0
</code></pre>

<p>By pushing the entries_needing_processing higher up in the order of fetching we are guaranteeing that we will be processing all entries and fetching all feeds. The big reason why this eliminates race conditions is because we are <strong>not</strong> pushing an entry back onto the entries_needing_processing list after popping it.</p>

<h3>Parallelizing the feed fetch</h3>

<p>So now we have a basic feed fetching script in place and we can squeeze some performance out of it. One of the lowest hanging fruits we can optimize is increasing the number of processes that pull stuff from our redis lists. With that in mind a preliminary attempt looks as follows:</p>

<pre><code>NUMBER_OF_WORKERS = 4
NUMBER_OF_WORKERS.times do
  Process.fork do
    redis = Redis.new
    loop do
      queue, payload = redis.blpop "entries_needing_processing", "feeds_to_fetch", 0
      if queue == "feeds_to_fetch"
        # Fetch feeds
        feed_url = payload
        puts "fetching feed: #{feed_url}"
        content = open(feed_url) { |s| s.read }
        rss = RSS::Parser.parse content, false
        rss.items.each do |entry|
          redis.rpush "entries_needing_processing", Marshal.dump([feed_url,entry])
        end
        redis.rpush "feeds_to_fetch", feed_url
      else
        # Process entries
        entry = Marshal.load payload
        puts "processing entry: #{entry.url}"
        entry_id = redis.incr "entries_processed"
        redis.hmset "entry|#{entry_id}", "url", entry.url, "title", entry.title, 
                    "published", entry.published, "description", entry.summary
        redis.sadd "entry_ids", entry_id
      end
    end
  end
end

Process.waitall
</code></pre>

<p>While this code works great, we see we have no way of gracefully bringing down our workers.</p>

<h3>Graceful shutdown of workers</h3>

<p>The next task we need to solve is have some way of being able to shutdown all the worker processes and the parent process after our script starts running. We could use something like signals for this, but having the parent process tell the child to kill themselves is something redis would be much better at doing.</p>

<pre><code>NUMBER_OF_WORKERS = 4
NUMBER_OF_WORKERS.times do
  Process.fork do
    redis = Redis.new
    loop do

      queue, payload = redis.blpop "message_from_master", "entries_needing_processing", 
                                    "feeds_to_fetch", 0
      exit(0) if queue == "message_from_master" &amp;&amp; payload == "DIE!"
      # rest of worker code
    end
  end
end

`echo #{Process.pid} &gt; /tmp/feed_processor.pid`
puts "Parent process wrote PID to /tmp/loyalize_master.pid"

trap('QUIT') do
  NUMBER_OF_WORKERS.times do
    redis.lpush "message_from_master", "DIE!"
  end
end

Process.waitall
</code></pre>

<p>The points of interest in the change here are marking <strong>message_from_master</strong> the first list in the order of priority. This way, when a worker is done processing either a feed or entry and is ready to fetch it&rsquo;s next task from redis, a message from master (aka the parent process) takes highest priority. In the parent process itself, we write out the PID to a file in the /tmp dir and trap the QUIT signal. In the signal handler, the parent just shoves down a DIE message on to the message_from_master queue, as many times as the number of worker processes it has spawned. And since a BLPOP is atomic we are guaranteed that each child is not going to pull out more than 1 of those DIE messages, so this way they all get to see this message. Race conditions goodbye! To see this in action and send the QUIT signal to the parent process we just need to run:</p>

<pre><code>kill -s QUIT `cat /tmp/feed_processor.pid`
</code></pre>

<h3>Protecting from the vagaries of the internet</h3>

<p>We are getting real close to being done here. One thing we can do is try hardening the script just a teeny bit by protecting the feed fetching portion of the script by wrapping it in a begin-ensure clause.</p>

<pre><code>if queue == "feeds_to_fetch"
  # Fetch feeds
  feed_url = payload
  begin
    puts "fetching feed: #{feed_url}"
    content = open(feed_url) { |s| s.read }
    rss = RSS::Parser.parse content, false
    rss.items.each do |entry|
      redis.rpush "entries_needing_processing", Marshal.dump([feed_url,entry])
    end
  ensure
    redis.rpush "feeds_to_fetch", feed_url
  end
else
</code></pre>

<h3>Conclusion</h3>

<p>While this is by no means a bullet-proof script it is an interesting exercise. It makes obvious just how big a role redis plays in an app where it&rsquo;s your primary or only datastore. Stuff like synchronization, mutexes, resource-contention, prioritized allocation of resources are all taken care of for you by redis. The full <a href="https://raw.github.com/santosh79/Feed-Processor/master/app.rb">Gist</a> is up. Enjoy!</p>

  </section>

  <section class="comments">

    <div id="disqus_thread"></div>
    <script type='text/javascript' src='http://santosh-log.disqus.com/embed.js'></script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>


  </section>
</article>

 
    </section>
  
  
  
  
  
  
  </body>
</html>

