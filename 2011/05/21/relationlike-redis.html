<!doctype html>
<html>
  <head>
    <link rel="stylesheet" type="text/css" href="/css/main.css">
    <link rel="alternate" type="application/atom+xml" title="Relation'like Redis - feed" href="/index.xml" />

    <script type="text/javascript">
      if((navigator.userAgent.match(/iPad/i))) {
        document.write("<meta name=\"viewport\" content=\"width=device-width; initial-scale=1.0; maximum-scale=1.0; user-scalable=0;\" />");
      } else if((navigator.userAgent.match(/iPhone/i))) {
        document.write("<meta name=\"viewport\" content=\"width=device-width; initial-scale=0.5; maximum-scale=1.0; user-scalable=1;\" />");
      }
    </script>

    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/> 
    <title>Relation'like Redis</title>
  </head>
  <body>
    <header id="main_header">
      <span>
        <a href="/">blog</a>
      </span>
      <span>
        <a href="http://santosh79.tumblr.com" target="_blank">tumblog</a>
      </span>
      <span>
        <a href="http://github.com/santosh79/" target="_blank">github</a>
      </span>
      <span>
        <a href="http://twitter.com/santosh79" target="_blank">@santosh79</a>
      </span>
      <span>
        <a href="/images/resume.html">resume</a>
      </span>
    </header>
    <section>
      <article class="post">
  <header>
    <div class="date_article_page">May 21st 2011</div>
    <h1>Relation'like Redis</h1>
  </header>

  <section class="content">
    <p><a href="http://redis.io/">Redis</a> is an insanely fast key value store developed by <a href="http://www.twitter.com/antirez">@antirez</a> that is being sponsored by <a href="http://www.vmware.com">VMWare</a>. One of the really great things about key-value stores is that they are super simple to reason about and understand. Recently, I&rsquo;ve been looking to migrate a twitter based app I had written <a href="http://www.bazaartwits.com">Bazaartwits</a> over to using Redis exclusively.</p>

<p>One of the first problems I am facing right-off-the-bat is that I have a convoluted relational set-up, where my tables are referencing each other pretty heavily. Before jumping head-long into this refactor, I had this rosy vision of my model-layer logic being neatly seperated into distinct keys and values. Sadly, this wasn&rsquo;t to be and I am figuring out that I should break this refactor into progressive steps. Where each step moves me a little further away from the relational model and closer to schema-less nirvana (or something like that).  If you find yourself in a situation similar to mine,  relax, Redis' got your back. With a little tweaking/nudging it can provide some of the relational features you have gotten painfully used to.</p>

<h3>The setup</h3>

<p>In order to highlight how to tweak Redis to bring forth some of it&rsquo;s relational-like features it makes sense to go with an example. Consider we have to model the following into Redis:
    Users: name, dob, [posts_made_by_user], :created_at
    Posts: text, [tags], created_at
    Tags: name, created_at</p>

<p>Here we have user&rsquo;s who each can have one or more posts. The posts themselves can be tagged by one or more keywords. Couple of common queries we need to plan for right now are:
    1. What are all the posts a given user has made?
    2. Which user has made the maximum number of posts?
    3. Which user made the most recent post?
    4. All the tags a given user has made?</p>

<p>So how do we model this?</p>

<h3>Models are hashes</h3>

<p>Store all your model&rsquo;s as hashes with key names <strong>model_name|model_id</strong>. An example of this would be:</p>

<pre><code>user|1 
</code></pre>

<p>Which is placed in redis as follows:</p>

<pre><code>redis.hmset "user|1", :name, "John Doe", 
  :dob, Time.parse("01/01/69").to_i, 
  :created_at, Time.parse("01/01/2007").to_i
</code></pre>

<h3>One-to-many associations</h3>

<p>The child model, i.e the one that belongs to a parent would have an attribute on it called <strong>parent_id</strong>. Example:</p>

<pre><code>redis.hmset "post|10", :text, "Sample Post", :user_id, 34
</code></pre>

<p>So, post:10 belongs to user:34. For modelling the parent, create a set of the format</p>

<pre><code>&lt;children&gt;_for_parent|&lt;parent_id&gt;
</code></pre>

<p>Example:</p>

<pre><code>redis.sadd "posts_for_user|10", 34
redis.sadd "posts_for_user|10", 720
</code></pre>

<p>User:10 has two post - 34 &amp; 720.</p>

<h3>Many-to-many associations</h3>

<p>As you would have guessed, many-to-many associations would be two sets of the form <strong>\&lt;first-model>_for_\&lt;second-model>|\&lt;second-model_id></strong> and <strong>\&lt;second-model>_for_\&lt;first-model>|\&lt;first_model_id></strong>. Example:</p>

<pre><code>redis.sadd "projects_for_user|4", 3
redis.sadd "projects_for_user|4", 20

redis.sadd "user_for_projects|10", 7
redis.sadd "user_for_projects|10", 19
</code></pre>

<p>So <strong>user:4</strong> has worked on projects 3 &amp; 20. While <strong>project:10</strong> has users 7 &amp; 19 on it. Simple.</p>

<h3>Setting up counter caches</h3>

<p>Much like in rails, it pays to keep count of the number of associations belonging to a model, the same applies to redis.</p>

<pre><code># Set the number of posts for a user
redis.hset "user|#{user_id}", "post_count", 
  redis.scard("posts_for_user|#{user_id}")
</code></pre>

<p>I&rsquo;ve created a  <a href="https://gist.github.com/985752">gist</a> with setting up redis for this example.</p>

<h3>Cranking out the queries</h3>

<p>Almost all the queries in this section are done using Redis' <a href="http://redis.io/commands/sort">sort command</a>. The sort command can do some pretty insane stuff, so it behooves digging into it a little.</p>

<h4>Redis' bad ass sort</h4>

<p>Redis supports sorting a list, set or sorted set. The most straightforward version is:</p>

<pre><code>redis.sort "list_that_needs_sorting"
And
redis.sort "list_that_needs_sorting", :order =&gt; "alpha"
</code></pre>

<p>This first sort does a numerical sort of the list while the second does an alphabetical sort.</p>

<h5>Caching the result</h5>

<p>Redis supports caching the result of a sort operation for a certain period of time so if a future sort query comes in that time window it just serves it the cached response. Example:</p>

<pre><code>redis.sort "list_that_needs_sorting", :order =&gt; "alpha", 
  :store =&gt; "sorted_list_results", :expire =&gt; 60
</code></pre>

<p>This stores the sorted results for a minute.</p>

<h5>Sorting by external keys</h5>

<p>Where the sorting becomes really interesting is when you are doing what Redis calls sorting by referencing external keys. This applies, in a situation where you are sorting a list or a set and the values contained in it are actually objects in redis. An example that highlights this:</p>

<pre><code>redis.sort "post_ids", :by =&gt; "post|*-&gt;text", 
  :order =&gt; "alpha desc", :get =&gt; "post|*-&gt;text"
</code></pre>

<p>This query basically tells redis, sort all the items in the post_ids set, and in each step grab the current id being sorted and do a lookup of the text attribute for the post matching that id AND give me back this text. How cool is that? You could also have it return back, just the post_id&rsquo;s themselves by using the <strong>:get => &ldquo;#&rdquo;</strong> syntax.</p>

<p>This returns all of the text attributes of posts, sorted by their text attributes in descending alphanumeric order. The <strong>|*-></strong> weird syntax is for hash traversals.</p>

<h4>List of all the user names</h4>

<p>With the knowledge of being able to do an external key lookup with the sort command, the query for listing all user names is:</p>

<pre><code>redis.sort "user_ids", :get =&gt; "user|*-&gt;name", 
  :by =&gt; "user|*-&gt;dont_worry_about_sorting_this"
</code></pre>

<p>The <strong>:by</strong> in this example, provides an non-existent attribute for attribute for sorting. In this case, redis just skips past the actual sorting operation and just does object lookup.</p>

<h5>List of tags sorted by their names</h5>

<pre><code>redis.sort "tag_ids", :get =&gt; "tag|*-&gt;name", 
  :by =&gt; "tag|*-&gt;name", :order =&gt; "alpha"
</code></pre>

<p>The order alpha is self-explanatory, you can also set it as <strong>alpha desc</strong> for descending order.</p>

<h5>What are all the posts a given user has made?</h5>

<pre><code>redis.sort "posts_for_user|#{user_id}", :get =&gt; "#"
</code></pre>

<h5>Which user has made the maximum number of posts?</h5>

<pre><code>redis.sort "user_ids", :by =&gt; "user|*-&gt;post_count", :get =&gt; "#", 
  :limit =&gt; [0,1], :order =&gt; "desc"
</code></pre>

<p>This query using the :limit option.</p>

<h5>Which user made the most recent post?</h5>

<pre><code>redis.sort "post_ids", :by =&gt; "post|*-&gt;created_at", 
  :get =&gt; "post|*-&gt;user_id", :limit =&gt; [0,1], :order =&gt; "desc"
</code></pre>

<h5>All the tags a given user has made?</h5>

<p>This is a two step process since we don&rsquo;t have a direct relation between tags and users:</p>

<pre><code># Step 1: Grab all the post id's the user has made
all_posts_made_by_user = redis.sort "posts_for_user|#{user_id}", :get =&gt; "#"
# Step 2: Perform a set union
redis.sunion *all_posts_made_by_user.map { |post_id| "tags_for_post|#{post_id}" }
</code></pre>

<p>While this might strike you as inefficient, believe me it is super efficient and fast. The first query returns back a pretty lean data structure of just an array of integers. While the second step, does redis' blinding fast set operations.</p>

<h3>Summary</h3>

<p>When working with Redis, you really want to make full use of it&rsquo;s speed. It doesn&rsquo;t make any sense, fetching values from redis and performing the sort in the confines of your program, unless you are programming in assembly. This not only is time inefficient, but more importantly is space inefficient. Your GC would need to run, to clean up objects in intermediate steps of a multi-step redis lookup. Redis also, is an in memory data store. This means that all the objects you store in Redis, are going to be in-memory. So think long and hard, about throwing in images or blobs in it (S3 is a far better place for those and just store the URL&rsquo;s in Redis). In spite, of being an in-memory data store it&rsquo;s remarkably stable and memory aware. Loading up Redis locally with a million users and 10 million posts (using the above schema) consumed no more than 500 MB in my machine!</p>

  </section>

  <section class="comments">

    <div id="disqus_thread"></div>
    <script type='text/javascript' src='http://santosh-log.disqus.com/embed.js'></script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>


  </section>
</article>

 
    </section>
  
  
  
  
  
  
  </body>
</html>

