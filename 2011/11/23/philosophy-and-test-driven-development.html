<!doctype html>
<html>
  <head>
    <link rel="stylesheet" type="text/css" href="/css/main.css">
    <link rel="alternate" type="application/atom+xml" title="Philosophy and Test Driven development - feed" href="/index.xml" />

    <script type="text/javascript">
      if((navigator.userAgent.match(/iPad/i))) {
        document.write("<meta name=\"viewport\" content=\"width=device-width; initial-scale=1.0; maximum-scale=1.0; user-scalable=0;\" />");
      } else if((navigator.userAgent.match(/iPhone/i))) {
        document.write("<meta name=\"viewport\" content=\"width=device-width; initial-scale=0.5; maximum-scale=1.0; user-scalable=1;\" />");
      }
    </script>

    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/> 
    <title>Philosophy and Test Driven development</title>
  </head>
  <body>
    <header id="main_header">
      <span>
        <a href="/">blog</a>
      </span>
      <span>
        <a href="http://santosh79.tumblr.com" target="_blank">tumblog</a>
      </span>
      <span>
        <a href="http://github.com/santosh79/" target="_blank">github</a>
      </span>
      <span>
        <a href="http://twitter.com/santosh79" target="_blank">@santosh79</a>
      </span>
      <span>
        <a href="/images/resume.html">resume</a>
      </span>
    </header>
    <section>
      <article class="post">
  <header>
    <div class="date_article_page">November 23rd 2011</div>
    <h1>Philosophy and Test Driven development</h1>
  </header>

  <section class="content">
    <p>For someone coming to test driven development for the first time &amp; even for those who have been dogmatically following it through the course of their work, the question &ldquo;What do I test?&rdquo;, still remains. In this blog, I am going to take a shot at answering that question using tools that Philosophy provides, specifically those employed by <a href="http://en.wikipedia.org/wiki/Immanuel_Kant">Immanuel Kant</a> in his ground-breaking <a href="http://en.wikipedia.org/wiki/Critique_of_Pure_Reason">First Critique of Pure Reason</a>. Those coming from a philosophical background, can see me drawing a hugely controversial line in the sand, and choosing to remain on the side <em>against</em> the <a href="http://plato.stanford.edu/entries/hume">empiricists</a> by my previous statement. Over the course of this blog, I will go on to defend this position and expand on why an empirical approach to Test Driven development is flawed.</p>

<h3>The Scientific Method and Test Driven Development</h3>

<p>Over the course of it&rsquo;s history, the term &ldquo;scientific method&rdquo; has gotten horribly and inexorably linked with empiricism. Here&rsquo;s why - the scientific method to most people means, measuring your way to some kind of truism. The empiricists, rejoice at this incorrect linkage, since this allows them to quiet conveniently slide in a bunch of probabilities into the mix and state confidently that somehow those probablities make that truism all that more true! The fact remains, that science (outside the realm of quantum mechanics which is still under &ldquo;study&rdquo;) follows Newtonian physics, which is distinctly anti-empirical. You don&rsquo;t remember &ldquo;A body continues in it&rsquo;s state of rest or constant motion unless an external force acts on it <em>with 99% probablity</em>&rdquo;. Instead, if you actually peel back a couple layers from the &ldquo;scientific method&rdquo; onion, you&rsquo;ll see scientists quiet often have &ldquo;theories&rdquo; (which is a polite way of saying they make stuff up) and then look at measurements as a way of testing the viablity of this theory. Only then, do they try getting the math right to make it acceptable. In many cases, theories just remain unprovable (proving alternate interior angles are equal in geometry for instance) and just remains as something we see and <em>feel</em> to be true, hence it is true.</p>

<p>So how does all this tie in with Test Driven Development? The answer is painfully simple - tests are <em>measurements</em>. So, when working with measurements we can choose to either follow the empirical approach of keeping the focus on measurements, or the Kant'ian and Common Sense approach of giving the benefit of doubt to the thing we think is true, unless we can prove measurably that it isn&rsquo;t.</p>

<p>So where does this lead us? It leads us to writing more <em>negative</em> tests that cover the edge-cases where the behavior of the system we are building is undefined or at the very least not something you think it&rsquo;s going to be. In mathematics parlance, if you are modelling in software a <a href="http://en.wikipedia.org/wiki/Continuous_function">non-continuous function</a> you need to be writing tests for where the &ldquo;continuity&rdquo; breaks down. An example,</p>

<pre><code>        -
F(x) = | 2,  x != 1
       | 10, x = 1
        -
</code></pre>

<p>A quick refresher, this is not a continuous function because the limit as this function approaches 1 from either negative or positive infinity is going to be 2, when in fact the value at 1 is 10. Using this as a guide, we see our test for this function should explicitly state the behavior of this function at 1.</p>

<h3>Tying it all together</h3>

<p>So how do we employ the Kant'ian world view in our software tests to make more maintainable, understandable software? Don&rsquo;t write tests for the obvious. If you are writing a function that sums up two numbers, don&rsquo;t write a test for that. Let that remain a law that&rsquo;s just understood to be true within the confines of your system. Software engineering after all is making abstract representations of reality. Reality, is that which impinges on our senses and gives us a model in space time of our surroundings. How do we know a table is a table? Does it fulfill some measurements that deem it to be a table? Nope, it just <strong>is</strong> a table. Similarly, how do we know that we call a sum() function that we have in written into our software system, it actually does add two numbers? We don&rsquo;t and we shouldn&rsquo;t be foolishly writing tests to state the obvious, it just <strong>is</strong>. On the other hand, given the following function:</p>

<pre><code>def sum(a, b)
  if a != 0 &amp;&amp; b != 0
    a + b
  else
    1.thousand
  end
end
</code></pre>

<p>Here this is most definitely not a continuous function and not something that we can just leave be. Write a test for the case where either a or b or both are zero.</p>

<h3>TL;DR</h3>

<p>As software engineers, we spend way too much time buried in the minutae of our world. Step out a several million feet, every once in a while and explore how philosopher&rsquo;s &amp; thinker&rsquo;s grappled with such fundamental concepts as reality &amp; truth&rsquo;s thereby laying the foundation for modern science. I can guarantee, you will get a far better perspective of what it is you and I are doing and more importantly what it is that we can take for granted and what it is that we shouldn&rsquo;t.</p>

  </section>

  <section class="comments">

    <div id="disqus_thread"></div>
    <script type='text/javascript' src='http://santosh-log.disqus.com/embed.js'></script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>


  </section>
</article>

 
    </section>
  
  
  
  
  
  
  </body>
</html>

