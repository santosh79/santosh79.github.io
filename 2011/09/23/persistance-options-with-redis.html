<!doctype html>
<html>
  <head>
    <link rel="stylesheet" type="text/css" href="/css/main.css">
    <link rel="alternate" type="application/atom+xml" title="Persistance options with Redis - feed" href="/index.xml" />

    <script type="text/javascript">
      if((navigator.userAgent.match(/iPad/i))) {
        document.write("<meta name=\"viewport\" content=\"width=device-width; initial-scale=1.0; maximum-scale=1.0; user-scalable=0;\" />");
      } else if((navigator.userAgent.match(/iPhone/i))) {
        document.write("<meta name=\"viewport\" content=\"width=device-width; initial-scale=0.5; maximum-scale=1.0; user-scalable=1;\" />");
      }
    </script>

    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/> 
    <title>Persistance options with Redis</title>
  </head>
  <body>
    <header id="main_header">
      <span>
        <a href="/">blog</a>
      </span>
      <span>
        <a href="http://santosh79.tumblr.com" target="_blank">tumblog</a>
      </span>
      <span>
        <a href="http://github.com/santosh79/" target="_blank">github</a>
      </span>
      <span>
        <a href="http://twitter.com/santosh79" target="_blank">@santosh79</a>
      </span>
      <span>
        <a href="/images/resume.html">resume</a>
      </span>
    </header>
    <section>
      <article class="post">
  <header>
    <div class="date_article_page">September 23rd 2011</div>
    <h1>Persistance options with Redis</h1>
  </header>

  <section class="content">
    <p>Most people thinking of Redis, think of it is an in-memory datastore. This is totally true. However, there is a lot of misconception with the &ldquo;in memory&rdquo; part; as being if my redis server crashes I lose all of my data. This part is most definitely <strong>not</strong> true. Redis persists your data to disk and provides you with all of the knobs you are going to need to need to fine tune how often you&rsquo;d like this persist to take place, while still eeking out the performance you&rsquo;d like to get out of redis.</p>

<h3>The two storage options</h3>

<p>A picture speaks a thousand words, so here goes:</p>

<h4>Option 1: Binary .rdb file</h4>

<pre><code> ----- 
|  R  |
|  E  |    Option 1     ---------------------
|  D  | -------------&gt; | Binary File (.rdb)  |
|  I  |                 ---------------------
|  S  |
 ----- 
</code></pre>

<h4>Option 2: A text file popularly known as an Append-Only File (AOF)</h4>

<pre><code> ----- 
|  R  |
|  E  |    Option 2     ---------------------
|  D  | -------------&gt; |  Text File (.aof)  |
|  I  |                 ---------------------
|  S  |
 ----- 
</code></pre>

<p>With both these options, you can create a brand new redis server with the data from your old redis server by simply copying the .rdb of .aof file and pointing your new redis server at the copied file.</p>

<h3>What&rsquo;s the difference?</h3>

<p>Besides the obvious fact, that one is in binary the other in text format, you may ask what&rsquo;s the difference between them? The Append Only File (AOF) is basically a log of all the commands your redis-server has run. Every single operation that your redis server has executed gets written to the AOF. So if you did:</p>

<pre><code>INCR USER_COUNT 1
INCR USER_COUNT 1
INCR USER_COUNT 1
</code></pre>

<p>In your AOF you will see all three increment operations. On the other hand, the binary .rdb file is basically a snapshot of all the keys and values in your redis server.</p>

<p>As you may have guessed, the AOF can grow really large since it&rsquo;s logging every operation; which is why redis has a command called <a href="http://redis.io/commands/bgrewriteaof">BGREWRITEAOF</a> that as the name suggests rewrites the AOF in the background. The re-write results in a file of way smaller size. Taking the example from above, let&rsquo;s say that after the third INCR USER_COUNT is now 10. The AOF file will have something along the lines of:</p>

<pre><code>SET USER_COUNT 10
</code></pre>

<h3>Why even have two formats?</h3>

<p>I mean, isn&rsquo;t it going to be a pain to remember to keep doing BGREWRITEAOF; or you risk running out of disk space? The AOF let&rsquo;s you do something special which the binary .rdb file just is not going to be able to do. Again, a picture will explain this way more clearly:</p>

<pre><code> R1  --&gt; /var/db/redis/file_one.aof
 R2  --&gt; /var/db/redis/file_two.aof
</code></pre>

<p>So you have two redis servers, each writing to their own files. You can now do:</p>

<pre><code>cat /var/db/redis/file_one.aof /var/db/redis/file_two.aof &gt;&gt; /var/db/redis/file_three.aof
</code></pre>

<p>And now bring up a new Redis server pointing at file_three.aof:</p>

<pre><code>R3  --&gt; /var/db/redis/file_three.aof
</code></pre>

<p>And this new redis server will have all of the data from servers R1 &amp; R2. How cool is that?!</p>

<h3>Merging data across all of your redis servers</h3>

<p>Going off on a tangent for a bit here and trying to re-hash the trick discussed above. Let&rsquo;s say you have multiple redis servers running and they are storing in binary format. You would now like to merge all of their data together, while the servers are running with zero downtime. Here&rsquo;s one way to go about it:</p>

<pre><code>redis-cli -p &lt;first-server-port&gt; CONFIG SET appendonly yes
redis-cli -p &lt;first-server-port&gt; BGREWRITEAOF
redis-cli -p &lt;first-server-port&gt; CONFIG SET appendonly no

redis-cli -p &lt;second-server-port&gt; CONFIG SET appendonly yes
redis-cli -p &lt;second-server-port&gt; BGREWRITEAOF
redis-cli -p &lt;second-server-port&gt; CONFIG SET appendonly no
</code></pre>

<p>All this is doing, is basically flipping the AOF switch, forcing your redis server&rsquo;s to rewrite their AOF&rsquo;s and then flipping it back to the binary storage format. You can now, merge these two AOF files by cat'ing them out to a third file as shown before and voila, you now have all of your data from your two redis servers in one AOF file that you can then use to bring up a new redis server (or as a backup).</p>

<h3>Which one is better?</h3>

<p>For most situations, using the binary format is better. When in doubt, avoid using the AOF - you run the risk of running out of diskspace if you forget to do a BGREWRITEAOF. And if you do end up having to merge data across multiple redis-servers, you could always do the trick shown above. The binary format is also a little faster in couple of redis-benchmarks that I had run.</p>

<h3>Fine tuning binary format save strategy</h3>

<p>Redis let&rsquo;s you specify how often you&rsquo;d like to take a snapshot of your redis DB and persist it to disk. A typical configuration entry that you will in a redis.conf file (<a href="https://github.com/santosh79/dot-files/blob/master/redis-dot.conf">here&rsquo;s an example of one</a> ) will have entries in the SNAPSHOTTING section that look like:</p>

<pre><code>save 900 1
save 300 10
save 60 10000
</code></pre>

<p>Read the first line as &ldquo;Snapshot the in-memory DB to disk every 900 seconds if only 1 key has changed&rdquo;. The second line as &ldquo;Snapshot the in-memory DB to disk every 300 seconds if only 10 keys have changed&rdquo;. And the last line as (you guessed it) &ldquo;Snapshot the in-memory DB to disk every 60 seconds if 10000 keys have changed&rdquo;. Now you can play with these parameters and tweak them as you see fit. For instance you could have something like:</p>

<pre><code>save 5 1
</code></pre>

<p>Where you&rsquo;ll be taking a snapshot of your DB every 5 seconds even if a single key has changed. Obviously this is going to come with a performance impact (since disk write&rsquo;s or fsync&rsquo;s as they are known the geek world are a time consuming operation), but Redis <strong>does</strong> support storing your stuff on disk even at this paranoid level! Finally, you can force a snapshot to happen anytime with the BGSAVE command.</p>

<h3>Fine tuning AOF save strategy</h3>

<p>In AOF mode, redis keeps logging what operations it&rsquo;s doing in-memory. You can tell redis how often you&rsquo;d like it to flush this in-memory buffer to disk. In the APPEND ONLY MODE section of a redis.conf file you will see an entry for <strong>appendfsync</strong>. Typical values are:</p>

<pre><code>appendfsync always
appendfsync everysec
appendfsync no
</code></pre>

<p>Where the <strong>always</strong> and <strong>everysec</strong> operations are pretty self-explanatory. The <strong>no</strong> option is kind of a misnomer. With the <strong>no</strong> option set, redis assumes no responsibility for deciding when it&rsquo;s flushing the in-memory AOF buffer to disk, it&rsquo;s let&rsquo;s the Operating System decide when it needs to be done. Of the three, the <strong>no</strong> option is generally the most performant, while at the same time being the most risky. The <strong>everysec</strong> option seems the most popular giving the best of both worlds.</p>

<h3>TL;DR</h3>

<p>Redis <strong>does</strong> store your data to disk and has numerous options that let you control how often you&rsquo;d like it to persist your data. So if this is what is holding you back from using Redis, don&rsquo;t let it anymore.</p>

  </section>

  <section class="comments">

    <div id="disqus_thread"></div>
    <script type='text/javascript' src='http://santosh-log.disqus.com/embed.js'></script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>


  </section>
</article>

 
    </section>
  
  
  
  
  
  
  </body>
</html>

