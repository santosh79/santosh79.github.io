<!doctype html>
<html>
  <head>
    <link rel="stylesheet" type="text/css" href="/css/main.css">
    <link rel="alternate" type="application/atom+xml" title="Expressing Ruby - feed" href="/index.xml" />

    <script type="text/javascript">
      if((navigator.userAgent.match(/iPad/i))) {
        document.write("<meta name=\"viewport\" content=\"width=device-width; initial-scale=1.0; maximum-scale=1.0; user-scalable=0;\" />");
      } else if((navigator.userAgent.match(/iPhone/i))) {
        document.write("<meta name=\"viewport\" content=\"width=device-width; initial-scale=0.5; maximum-scale=1.0; user-scalable=1;\" />");
      }
    </script>

    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/> 
    <title>Expressing Ruby</title>
  </head>
  <body>
    <header id="main_header">
      <span>
        <a href="/">blog</a>
      </span>
      <span>
        <a href="http://santosh79.tumblr.com" target="_blank">tumblog</a>
      </span>
      <span>
        <a href="http://github.com/santosh79/" target="_blank">github</a>
      </span>
      <span>
        <a href="http://twitter.com/santosh79" target="_blank">@santosh79</a>
      </span>
      <span>
        <a href="/images/resume.html">resume</a>
      </span>
    </header>
    <section>
      <article class="post">
  <header>
    <div class="date_article_page">March 27th 2011</div>
    <h1>Expressing Ruby</h1>
  </header>

  <section class="content">
    <p>Anyone who has programmed in Ruby for even a short period of time, has probably walked away amazed at how expressive the language is. Right, right? Why is it then that, often times you are out there reading ruby code and the word <em>expressiveness</em> is not the first adjective that comes to your mind? My belief is that, Ruby, an expressive language be as it may; still needs to be written in a way the language designers had intended it to be written. If python embraces &lsquo;Explicit is better than implicit&rsquo; and Perl &lsquo;There is more than one (hundred) way(s) to do it&rsquo;, Ruby finds itself in a happy medium somewhere between the two. It is this Rilke'esque capacity by Matz to weigh difficult choices and make decisions, not based on any rigid philosphies, that has made Ruby what it is today.</p>

<p>I now hear you go &lsquo;Show me some codez, already!&rsquo;. Well&hellip; here goes:</p>

<h4>Let go of your freakin self</h4>

<p>Ruby is not Python. We don&rsquo;t need to be passing self all over the place &amp; heaven knows we don&rsquo;t really need to be using it.</p>

<pre><code>class Account
  def inactive?
    !self.active?
  end
end
</code></pre>

<p>Do we really need to be having that <em>self</em> there in that inactive? method? No, we most definitely don&rsquo;t. The argument you will hear, for it&rsquo;s use in that method would be; by sticking that &lsquo;self&rsquo; in front of active? the code is being explicit about the method call. That is, by saying self.active? the code is being explicit about calling the active? method. Well that is freaking fine, but this is NOT Python and being explicit is not the way Ruby was intended to be written. Choosing expressiveness over explicitness, to me feels right, since expressiveness brings with it an improved understanding and this renders being explicit moot. Besides, that&rsquo;s what tests are meant to solve. So let&rsquo;s see how the code looks now without the redundant &lsquo;self&rsquo; in it:</p>

<pre><code>class Account
  def inactive?
    !active?
  end
end
</code></pre>

<p>Just reading this, to me feels better. What is an inactive account? Looking at the code I see it is a not active ( ! active? ) account. Now, I am not suggesting pulling up a 500-line ruby method in your code-base, that has no test coverage &amp; yanking out all the explicit method calls. All I&rsquo;m saying is, being a little intelligent &amp; stingy about calling self just makes code more readable &amp; expressive.</p>

<h4>Flip out big unless conditional logic with if&rsquo;s and write negative methods</h4>

<p> Here we have a Rails controller that has some twisted convoluted logic:</p>

<pre><code>class DocumentsController &lt; ApplicationController
  def index
    unless current_user.any_non_system_accounts? ||
            session[:some_session_key].present?   ||
            current_user.send_invitation?
      redirect_to comments_path
    else
      redirect_to users_path
    end
  end 
end 
</code></pre>

<p>The unless conditional logic is not something that is easily understandable, let alone expressive. By understandable, I mean, it does not just register in my mind in about 20 seconds of reading. If the current_user has any non-system accounts OR if there is something in the session OR if the current_user is sending an invitation &ndash; take the NOT of that and if that evaluates to true, the request is redirected to the comments page. Not understandable! The first big stab, we can take at cleaning it up is replacing the unless with an if. To do that, a quick primer on boolean algebra 101 courtesy <a href="http://en.wikipedia.org/wiki/Augustus_De_Morgan">Augustus Demorgan</a>:</p>

<pre><code>!(A OR B OR C) == (!A) AND (!B) AND (!C)
!(A AND B AND C) == (!A) OR (!B) OR (!C)
</code></pre>

<p>So, in our case we can avail of the first theorem, since an unless is a !if.</p>

<pre><code>class DocumentsController &lt; ApplicationController
  def index
    if !current_user.any_non_system_accounts? &amp;&amp;
        !session[:some_session_key].present? &amp;&amp;
        !current_user.send_invitation?
      redirect_to comments_path
    else
      redirect_to users_path
    end
  end 
end 
</code></pre>

<p>This now reads &ndash; if the current_user has no non-system accounts AND some session key is not present AND the current_user is not sending an invitation THEN send a 304 to the comments page ELSE a 304 to the users page. Definitely better, but not quite there yet. What would truly make this code expressive is adding what I call negative methods into the mix. A quick example &ndash; let&rsquo;s say we want to add a negative method on the User object that does the negation of the any_non_system_accounts? method. What would we call this negative method? So it&rsquo;s going to return the negation of any_non_system_accounts?. That&rsquo;s easy, it would just be has_system_accounts?. I stuck the word &lsquo;has&rsquo; in this new negation method. This is a stylistic preference on my part, that to me adds a certain garnish on the ruby expressiveness sauce. The code now morphs into:</p>

<pre><code>class DocumentsController &lt; ApplicationController
  def index
    if current_user.has_system_accounts &amp;&amp; 
      session[:some_session_key].blank? &amp;&amp;
      current_user.dont_send_invitation
        redirect_to comments_path
    else
        redirect_to users_path
    end
  end
end 
</code></pre>

<p>If the current_user has system accounts AND a session variable is blank AND an invitation should not be sent to the current user then I redirect to the comments page. Much better.</p>

<h4>Guard blocks are NOT always bad</h4>

<p>This is considered heresy by many, but to me I find they bring a boat load of expressiveness to the language. What is a guard block? It&rsquo;s basically a code pattern where the first statement in a method looks for certain conditions and breaks out of the method if those don&rsquo;t work. Here is a method that is crying for a guard block:</p>

<pre><code>def send_email
  if has_email? &amp;&amp; email_is_valid?
    if gmail_email_address?
      send_email_using_gmail_whitelisted_ip
      audit_this_event
    else
      send_email_using_any_ip
    end
  end
end
</code></pre>

<p> Ok, so this send_email method reads reasonably well. If we have an email and the email is valid, we then do checks to see if it is a gmail.com email alias. Depending on whether it is or isn&rsquo;t we choose to send it out via smtp servers residing on certain IP&rsquo;s. Fair enough. But what is the bare essential, this method needs for performing it&rsquo;s task? It needs an email and that email has to be a valid one. Making that a guard block, makes it explicit as to what this method expects the state is going to be when it gets invoked. With a guard block the code morphs to:</p>

<pre><code>def send_email
  return unless has_email &amp;&amp; email_is_valid?

  if gmail_email_address?
    send_email_using_gmail_whitelisted_ip
    audit_this_event
  else
    send_email_using_any_ip
  end
end
</code></pre>

<p>Reading this, I know instantly that this method expects there to be the presence of an email and it being valid.</p>

<h4>Use Keyword operators instead of ||, &amp;&amp; and !</h4>

<p>This is further deep in the bowels of heretical waters. Ruby provides keyword operators AND, OR and NOT which are far more expressive that their &amp;&amp;, || and ! cousins. There are cases, where they should not be used &ndash; such as when used in combination with a ternary operator or when the result of the conditional evaluation is being captured. Examples:</p>

<pre><code>z = "purple" &amp;&amp; "gello" # z =&gt; "gello"
z = "purple" AND "gello" # z =&gt; "purple"

result = true &amp;&amp; true ? "hi" : "bye" # result is "hi"
result = true AND true ? "hi" : "bye" # result is "bye"
</code></pre>

<p>These are a side-effect of the keyword operators having lower precedence than their &amp;&amp;, || and ! cousins. But, in most situations that require the use of conditional logic using them should work just fine. To see the expressiveness they bring to the party, revisiting the Account inactive example and sprinkling the keyword operators in there yields:</p>

<pre><code>class Account
  def inactive?
    not active?
  end
end
</code></pre>

<p>Way more expressive!</p>

<h3>Summary</h3>

<p>Be brave &amp; trust in Ruby. Try stepping out of the way and let Ruby express itself. That&rsquo;s what it was built for. Not to be blazing fast, but a modern language written with the knowledge that we spend far more time reading code than writing it. Oh, and don&rsquo;t forget to write your tests&hellip;</p>

  </section>

  <section class="comments">

    <div id="disqus_thread"></div>
    <script type='text/javascript' src='http://santosh-log.disqus.com/embed.js'></script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>


  </section>
</article>

 
    </section>
  
  
  
  
  
  
  </body>
</html>

